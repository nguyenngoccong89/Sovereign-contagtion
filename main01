import numpy as np
import math
import time
from dataclasses import dataclass
from numba import njit, prange

# ============================================================
# 0. Params / grids (your calibration table + solver knobs)
# ============================================================

@dataclass
class Params:
    # Household + public goods
    sigma_H: float = 2.0
    theta: float = 1.0
    nu: float = 2.0
    omega_g: float = 0.40
    beta: float = 0.90

    # Productivity
    rho_z: float = 0.90
    sigma_eps: float = 0.02
    NZ: int = 7
    tauchen_m: float = 3.0

    # Default penalty: z_def = min(z, delta*zbar)
    delta_def: float = 0.90

    # Market access: Pr(reenter | excluded) = lambda
    lam_reentry: float = 0.20

    # Lender (CRRA)
    sigma_L: float = 2.5
    beta_L: float = 0.98
    y_L: float = 0.80

    # EV smoothing scales
    rho_a: float = 0.01   # repay action smoothing over (b',tau)
    rho_d: float = 0.01   # default vs repay smoothing
    euler_gamma: float = 0.5772156649015329

    # Iteration / damping
    max_iter: int = 800
    tol: float = 1e-6
    damp: float = 0.30

    # Newton for lender-consumption root (pricing)
    newton_maxit: int = 30
    newton_tol: float = 1e-12


@dataclass
class Grids:
    bO: np.ndarray
    bP: np.ndarray
    tauO: np.ndarray
    tauP: np.ndarray
    iBO0: int
    iBP0: int


def make_grids_10():
    # 10 grid points each for B and tau
    bO = np.linspace(0.0, 0.40, 10)
    bP = np.linspace(0.0, 0.40, 10)
    tauO = np.linspace(0.0, 0.30, 10)
    tauP = np.linspace(0.0, 0.30, 10)
    iBO0 = int(np.argmin(np.abs(bO - 0.0)))
    iBP0 = int(np.argmin(np.abs(bP - 0.0)))
    # enforce exact zeros if close
    bO[iBO0] = 0.0
    bP[iBP0] = 0.0
    return Grids(bO=bO, bP=bP, tauO=tauO, tauP=tauP, iBO0=iBO0, iBP0=iBP0)


# ============================================================
# 1. Tauchen + joint process (no correlation)
# ============================================================

def _norm_cdf(x):
    return 0.5 * (1.0 + math.erf(x / math.sqrt(2.0)))

def tauchen_logz(N, rho, sigma_eps, m):
    sigma_z = sigma_eps / np.sqrt(1 - rho**2)
    zmax = m * sigma_z
    zmin = -zmax
    grid = np.linspace(zmin, zmax, N)
    step = grid[1] - grid[0]

    Pi = np.zeros((N, N))
    for i in range(N):
        for j in range(N):
            if j == 0:
                Pi[i, j] = _norm_cdf((grid[0] - rho * grid[i] + step / 2) / sigma_eps)
            elif j == N - 1:
                Pi[i, j] = 1 - _norm_cdf((grid[-1] - rho * grid[i] - step / 2) / sigma_eps)
            else:
                z_low = (grid[j] - rho * grid[i] - step / 2) / sigma_eps
                z_high = (grid[j] - rho * grid[i] + step / 2) / sigma_eps
                Pi[i, j] = _norm_cdf(z_high) - _norm_cdf(z_low)

    # stationary dist
    pi = np.ones(N) / N
    for _ in range(20000):
        pi_new = pi @ Pi
        if np.max(np.abs(pi_new - pi)) < 1e-14:
            break
        pi = pi_new

    return grid, np.exp(grid), Pi, pi


def build_joint_z(params: Params):
    logz, z, Pi, pi = tauchen_logz(params.NZ, params.rho_z, params.sigma_eps, params.tauchen_m)
    # independence => kron
    Pi2 = np.kron(Pi, Pi)            # NZ^2 x NZ^2
    zO = np.repeat(z, params.NZ)     # length NZ^2
    zP = np.tile(z, params.NZ)

    zbar = float(np.sum(pi * z))
    z_def = np.minimum(z, params.delta_def * zbar)
    zO_def = np.repeat(z_def, params.NZ)
    zP_def = np.tile(z_def, params.NZ)

    return zO, zP, zO_def, zP_def, Pi2


# ============================================================
# 2. Static household block (GHH + consumption tax)
#    Now using numba-friendly precompute
# ============================================================

@njit
def _precompute_static_arrays(zO, zP, zO_def, zP_def, tauO, tauP,
                               theta, nu, sigma_H, omega_g):
    """Precompute static household block arrays for all (z, tau)."""
    NZ2 = zO.size
    NTO = tauO.size
    NTP = tauP.size

    uO = np.empty((NZ2, NTO))
    TO = np.empty((NZ2, NTO))
    uO_def = np.empty((NZ2, NTO))
    TO_def = np.empty((NZ2, NTO))
    uP = np.empty((NZ2, NTP))
    TP = np.empty((NZ2, NTP))
    uP_def = np.empty((NZ2, NTP))
    TP_def = np.empty((NZ2, NTP))

    for iz in range(NZ2):
        # O normal
        for it in range(NTO):
            z = zO[iz]; tau = tauO[it]
            l = (z / (theta * (1.0 + tau))) ** (1.0 / nu)
            y = z * l
            c = y / (1.0 + tau)
            T = tau * c
            inside = c - theta * (l ** (1.0 + nu)) / (1.0 + nu)
            if inside > 0:
                uO[iz, it] = (inside ** (1.0 - sigma_H)) / (1.0 - sigma_H)
            else:
                uO[iz, it] = -1e12
            TO[iz, it] = T

            # O default
            zd = zO_def[iz]
            ld = (zd / (theta * (1.0 + tau))) ** (1.0 / nu)
            yd = zd * ld
            cd = yd / (1.0 + tau)
            Td = tau * cd
            inside_d = cd - theta * (ld ** (1.0 + nu)) / (1.0 + nu)
            if inside_d > 0:
                uO_def[iz, it] = (inside_d ** (1.0 - sigma_H)) / (1.0 - sigma_H)
            else:
                uO_def[iz, it] = -1e12
            TO_def[iz, it] = Td

        # P normal
        for it in range(NTP):
            z = zP[iz]; tau = tauP[it]
            l = (z / (theta * (1.0 + tau))) ** (1.0 / nu)
            y = z * l
            c = y / (1.0 + tau)
            T = tau * c
            inside = c - theta * (l ** (1.0 + nu)) / (1.0 + nu)
            if inside > 0:
                uP[iz, it] = (inside ** (1.0 - sigma_H)) / (1.0 - sigma_H)
            else:
                uP[iz, it] = -1e12
            TP[iz, it] = T

            # P default
            zd = zP_def[iz]
            ld = (zd / (theta * (1.0 + tau))) ** (1.0 / nu)
            yd = zd * ld
            cd = yd / (1.0 + tau)
            Td = tau * cd
            inside_d = cd - theta * (ld ** (1.0 + nu)) / (1.0 + nu)
            if inside_d > 0:
                uP_def[iz, it] = (inside_d ** (1.0 - sigma_H)) / (1.0 - sigma_H)
            else:
                uP_def[iz, it] = -1e12
            TP_def[iz, it] = Td

    return uO, TO, uO_def, TO_def, uP, TP, uP_def, TP_def


# ============================================================
# 3. Numba EV helpers
# ============================================================

@njit
def _v_pub(g, omega_g, sigma_H):
    """Public goods utility for scalar g."""
    if g > 0:
        return omega_g * (g ** (1.0 - sigma_H)) / (1.0 - sigma_H)
    else:
        return -1e12


@njit
def _logsumexp_1d(W, rho):
    """
    For 1d array W, compute:
      inc = rho * log(sum(exp(W/rho)))
      probs = softmax(W/rho)
    Returns (inc_scalar, probs_array).
    """
    n = W.size
    mx = W[0]
    for i in range(1, n):
        if W[i] > mx:
            mx = W[i]
    S = 0.0
    probs = np.empty(n)
    for i in range(n):
        probs[i] = np.exp((W[i] - mx) / rho)
        S += probs[i]
    for i in range(n):
        probs[i] /= S
    inc = rho * (np.log(S) + mx / rho)
    return inc, probs


@njit
def _default_prob(Vdef, Vrep, rho_d):
    mx = max(Vdef, Vrep)
    num = np.exp((Vdef - mx) / rho_d)
    den = num + np.exp((Vrep - mx) / rho_d)
    return num / den


@njit
def _inclusive_two(Vdef, Vrep, rho_d, gamma):
    mx = max(Vdef, Vrep)
    return gamma * rho_d + rho_d * (np.log(np.exp((Vdef - mx) / rho_d) + np.exp((Vrep - mx) / rho_d)) + mx / rho_d)


@njit
def _solve_c_newton_vec(A, K, sigma_L, maxit, tol):
    """Solve c + c^sigma_L * K = A element-wise for 2D arrays."""
    rows, cols = K.shape
    c = np.empty((rows, cols))
    for i in range(rows):
        for j in range(cols):
            ci = max(A, 1e-12)
            for _ in range(maxit):
                c_pow = ci ** sigma_L
                f = ci + c_pow * K[i, j] - A
                if abs(f) < tol:
                    break
                df = 1.0 + sigma_L * (ci ** (sigma_L - 1.0)) * K[i, j]
                ci = max(ci - f / df, 1e-12)
            c[i, j] = ci
    return c


@njit
def _solve_c_newton_1d(A, K, sigma_L, maxit, tol):
    """Solve c + c^sigma_L * K = A element-wise for 1D array K."""
    n = K.size
    c = np.empty(n)
    for i in range(n):
        ci = max(A, 1e-12)
        for _ in range(maxit):
            c_pow = ci ** sigma_L
            f = ci + c_pow * K[i] - A
            if abs(f) < tol:
                break
            df = 1.0 + sigma_L * (ci ** (sigma_L - 1.0)) * K[i]
            ci = max(ci - f / df, 1e-12)
        c[i] = ci
    return c


# ============================================================
# 4. Container for equilibrium objects (4 regimes)
# ============================================================

@dataclass
class Eq:
    VO: np.ndarray
    VP: np.ndarray
    dO: np.ndarray
    dP: np.ndarray
    muL: np.ndarray
    EbO_rep: np.ndarray
    EtauO_rep: np.ndarray
    EtauO_def: np.ndarray
    EbP_rep: np.ndarray
    EtauP_rep: np.ndarray
    EtauP_def: np.ndarray
    dP_if_Orep: np.ndarray
    EbP_if_Orep: np.ndarray
    EtauP_if_Orep: np.ndarray
    dP_if_Odef: np.ndarray
    EbP_if_Odef: np.ndarray
    EtauP_if_Odef: np.ndarray
    qO_pol: np.ndarray
    qP_pol: np.ndarray


def init_eq(params: Params, grids: Grids):
    NZ2 = params.NZ * params.NZ
    NB = grids.bO.size
    shape = (NZ2, NB, NB, 2, 2)

    VO = np.zeros(shape)
    VP = np.zeros(shape)
    dO = np.zeros(shape)
    dP = np.zeros(shape)
    muL = np.full(shape, params.y_L ** (-params.sigma_L))

    EbO_rep = np.zeros(shape); EtauO_rep = np.zeros(shape); EtauO_def = np.zeros(shape)
    EbP_rep = np.zeros(shape); EtauP_rep = np.zeros(shape); EtauP_def = np.zeros(shape)
    dP_if_Orep = np.zeros(shape); EbP_if_Orep = np.zeros(shape); EtauP_if_Orep = np.zeros(shape)
    dP_if_Odef = np.zeros(shape); EbP_if_Odef = np.zeros(shape); EtauP_if_Odef = np.zeros(shape)
    qO_pol = np.zeros(shape); qP_pol = np.zeros(shape)

    dO[:, :, :, 1, :] = 1.0
    dP[:, :, :, :, 1] = 1.0

    return Eq(VO, VP, dO, dP, muL,
              EbO_rep, EtauO_rep, EtauO_def,
              EbP_rep, EtauP_rep, EtauP_def,
              dP_if_Orep, EbP_if_Orep, EtauP_if_Orep,
              dP_if_Odef, EbP_if_Odef, EtauP_if_Odef,
              qO_pol, qP_pol)


# ============================================================
# 5. Expectations over z' (vectorized, no numba needed)
# ============================================================

def expected_over_z(Pi2, X):
    NZ2 = Pi2.shape[0]
    Xr = X.reshape(NZ2, -1)
    EX = Pi2 @ Xr
    return EX.reshape(X.shape)


def build_expectations(params: Params, grids: Grids, Pi2, eq: Eq):
    NZ2 = params.NZ * params.NZ
    NB = grids.bO.size

    EV_VO = np.zeros((2, 2, NZ2, NB, NB))
    EV_VP = np.zeros((2, 2, NZ2, NB, NB))
    N_O = np.zeros((2, 2, NZ2, NB, NB))
    N_P = np.zeros((2, 2, NZ2, NB, NB))

    for mO in (0, 1):
        for mP in (0, 1):
            VO_slice = eq.VO[:, :, :, mO, mP]
            VP_slice = eq.VP[:, :, :, mO, mP]
            EV_VO[mO, mP] = expected_over_z(Pi2, VO_slice)
            EV_VP[mO, mP] = expected_over_z(Pi2, VP_slice)

            X_O = eq.muL[:, :, :, mO, mP] * (1.0 - eq.dO[:, :, :, mO, mP])
            X_P = eq.muL[:, :, :, mO, mP] * (1.0 - eq.dP[:, :, :, mO, mP])
            N_O[mO, mP] = params.beta_L * expected_over_z(Pi2, X_O)
            N_P[mO, mP] = params.beta_L * expected_over_z(Pi2, X_P)

    return EV_VO, EV_VP, N_O, N_P


# ============================================================
# 6. Core regime solver (0,0) -- fully numba JIT
# ============================================================

@njit
def _solve_regime_00_core(
    NZ2, NB, NT_O, NT_P,
    bOgrid, bPgrid, tauO, tauP,
    iBO0, iBP0,
    uO_all, TO_all, uO_def_all, TO_def_all,
    uP_all, TP_all, uP_def_all, TP_def_all,
    NO_00, NP_00, NO_01, NP_10,
    EVOO_00, EVOO_01, EVOO_10, EVOO_11,
    EVPP_00, EVPP_01, EVPP_10, EVPP_11,
    sigma_H, omega_g, beta, sigma_L, y_L,
    rho_a, rho_d, euler_gamma,
    newton_maxit, newton_tol
):
    """Core (0,0) regime solver, fully compiled with numba."""

    # outputs
    VO00 = np.zeros((NZ2, NB, NB))
    VP00 = np.zeros((NZ2, NB, NB))
    dO00 = np.zeros((NZ2, NB, NB))
    dP00 = np.zeros((NZ2, NB, NB))
    mu00 = np.zeros((NZ2, NB, NB))
    EbO_rep = np.zeros((NZ2, NB, NB))
    EtauO_rep = np.zeros((NZ2, NB, NB))
    EtauO_def = np.zeros((NZ2, NB, NB))
    EbP_rep = np.zeros((NZ2, NB, NB))
    EtauP_rep = np.zeros((NZ2, NB, NB))
    EtauP_def = np.zeros((NZ2, NB, NB))
    dP_if_Orep_out = np.zeros((NZ2, NB, NB))
    EbP_if_Orep_out = np.zeros((NZ2, NB, NB))
    EtauP_if_Orep_out = np.zeros((NZ2, NB, NB))
    dP_if_Odef_out = np.zeros((NZ2, NB, NB))
    EbP_if_Odef_out = np.zeros((NZ2, NB, NB))
    EtauP_if_Odef_out = np.zeros((NZ2, NB, NB))
    qO_pol_out = np.zeros((NZ2, NB, NB))
    qP_pol_out = np.zeros((NZ2, NB, NB))

    for iz2 in range(NZ2):
        uO_tau = uO_all[iz2, :]
        TO_tau = TO_all[iz2, :]
        uO_d_tau = uO_def_all[iz2, :]
        TO_d_tau = TO_def_all[iz2, :]
        uP_tau = uP_all[iz2, :]
        TP_tau = TP_all[iz2, :]
        uP_d_tau = uP_def_all[iz2, :]
        TP_d_tau = TP_def_all[iz2, :]

        NO00 = NO_00[iz2, :, :]
        NP00 = NP_00[iz2, :, :]
        NO01_bO = NO_01[iz2, :, iBP0]
        NP10_bP = NP_10[iz2, iBO0, :]

        EVO00 = EVOO_00[iz2, :, :]
        EVO01 = EVOO_01[iz2, :, :]
        EVO10 = EVOO_10[iz2, :, :]
        EVO11 = EVOO_11[iz2, :, :]
        EVP00 = EVPP_00[iz2, :, :]
        EVP01 = EVPP_01[iz2, :, :]
        EVP10 = EVPP_10[iz2, :, :]
        EVP11 = EVPP_11[iz2, :, :]

        for iBO in range(NB):
            bO_now = bOgrid[iBO]
            for iBP in range(NB):
                bP_now = bPgrid[iBP]

                # A) PRICE SCHEDULES
                # 1) both issue
                A_both = y_L + bO_now + bP_now
                K_both = np.empty((NB, NB))
                for i in range(NB):
                    for j in range(NB):
                        K_both[i, j] = NO00[i, j] * bOgrid[i] + NP00[i, j] * bPgrid[j]
                c_both = _solve_c_newton_vec(A_both, K_both, sigma_L, newton_maxit, newton_tol)
                qO_both = np.empty((NB, NB))
                qP_both = np.empty((NB, NB))
                for i in range(NB):
                    for j in range(NB):
                        cp = c_both[i, j] ** sigma_L
                        qO_both[i, j] = NO00[i, j] * cp
                        qP_both[i, j] = NP00[i, j] * cp

                # 2) only O issues (P defaults)
                A_onlyO = y_L + bO_now
                K_onlyO = np.empty(NB)
                for i in range(NB):
                    K_onlyO[i] = NO01_bO[i] * bOgrid[i]
                c_onlyO = _solve_c_newton_1d(A_onlyO, K_onlyO, sigma_L, newton_maxit, newton_tol)
                qO_onlyO = np.empty(NB)
                for i in range(NB):
                    qO_onlyO[i] = NO01_bO[i] * (c_onlyO[i] ** sigma_L)

                # 3) only P issues (O defaults)
                A_onlyP = y_L + bP_now
                K_onlyP = np.empty(NB)
                for i in range(NB):
                    K_onlyP[i] = NP10_bP[i] * bPgrid[i]
                c_onlyP = _solve_c_newton_1d(A_onlyP, K_onlyP, sigma_L, newton_maxit, newton_tol)
                qP_onlyP = np.empty(NB)
                for i in range(NB):
                    qP_onlyP[i] = NP10_bP[i] * (c_onlyP[i] ** sigma_L)

                # B) FOLLOWER (P) given O REPAYS
                VP_cond_Orep = np.zeros(NB)
                dP_cond_Orep = np.zeros(NB)
                p_bP_condrep = np.zeros((NB, NB))
                EbP_condrep = np.zeros(NB)
                EtauP_condrep = np.zeros(NB)
                EtauP_def_cond = np.zeros(NB)

                for jBOp in range(NB):
                    # P repay value index over (tauP, bP')
                    W_flat = np.empty(NT_P * NB)
                    idx = 0
                    for it in range(NT_P):
                        for jb in range(NB):
                            gP = TP_tau[it] + qP_both[jBOp, jb] * bPgrid[jb] - bP_now
                            vg = _v_pub(gP, omega_g, sigma_H)
                            cont = beta * EVP00[jBOp, jb]
                            W_flat[idx] = uP_tau[it] + vg + cont
                            idx += 1
                    Vrep_inc, probs = _logsumexp_1d(W_flat, rho_a)
                    VrepP = euler_gamma * rho_a + Vrep_inc

                    # conditional-on-repay expectations
                    p_bP = np.zeros(NB)
                    p_tau = np.zeros(NT_P)
                    idx = 0
                    for it in range(NT_P):
                        for jb in range(NB):
                            p_bP[jb] += probs[idx]
                            p_tau[it] += probs[idx]
                            idx += 1
                    EbP = 0.0
                    for jb in range(NB):
                        EbP += p_bP[jb] * bPgrid[jb]
                    Etau = 0.0
                    for it in range(NT_P):
                        Etau += p_tau[it] * tauP[it]

                    # P default value
                    Wdef_tau = np.empty(NT_P)
                    Cont_def = beta * EVP01[jBOp, iBP0]
                    for it in range(NT_P):
                        vg = _v_pub(TP_d_tau[it], omega_g, sigma_H)
                        Wdef_tau[it] = uP_d_tau[it] + vg + Cont_def
                    Vdef_inc, p_tau_def = _logsumexp_1d(Wdef_tau, rho_a)
                    VdefP = euler_gamma * rho_a + Vdef_inc
                    Etau_def = 0.0
                    for it in range(NT_P):
                        Etau_def += p_tau_def[it] * tauP[it]

                    dP_here = _default_prob(VdefP, VrepP, rho_d)
                    VP_here = _inclusive_two(VdefP, VrepP, rho_d, euler_gamma)

                    VP_cond_Orep[jBOp] = VP_here
                    dP_cond_Orep[jBOp] = dP_here
                    for jb in range(NB):
                        p_bP_condrep[jBOp, jb] = p_bP[jb]
                    EbP_condrep[jBOp] = EbP
                    EtauP_condrep[jBOp] = Etau
                    EtauP_def_cond[jBOp] = Etau_def

                # C) FOLLOWER (P) when O DEFAULTS
                W_flat = np.empty(NT_P * NB)
                idx = 0
                for it in range(NT_P):
                    for jb in range(NB):
                        gP = TP_tau[it] + qP_onlyP[jb] * bPgrid[jb] - bP_now
                        vg = _v_pub(gP, omega_g, sigma_H)
                        cont = beta * EVP10[iBO0, jb]
                        W_flat[idx] = uP_tau[it] + vg + cont
                        idx += 1
                Vrep_inc_od, probs_od = _logsumexp_1d(W_flat, rho_a)
                VrepP_od = euler_gamma * rho_a + Vrep_inc_od
                p_bP_od = np.zeros(NB)
                idx = 0
                for it in range(NT_P):
                    for jb in range(NB):
                        p_bP_od[jb] += probs_od[idx]
                        idx += 1
                EbP_od = 0.0
                for jb in range(NB):
                    EbP_od += p_bP_od[jb] * bPgrid[jb]
                p_tau_od = np.zeros(NT_P)
                idx = 0
                for it in range(NT_P):
                    for jb in range(NB):
                        p_tau_od[it] += probs_od[idx]
                        idx += 1
                EtauP_od = 0.0
                for it in range(NT_P):
                    EtauP_od += p_tau_od[it] * tauP[it]

                Wdef_tau_od = np.empty(NT_P)
                Cont_def_od = beta * EVP11[iBO0, iBP0]
                for it in range(NT_P):
                    vg = _v_pub(TP_d_tau[it], omega_g, sigma_H)
                    Wdef_tau_od[it] = uP_d_tau[it] + vg + Cont_def_od
                Vdef_inc_od, p_tau_def_od = _logsumexp_1d(Wdef_tau_od, rho_a)
                VdefP_od = euler_gamma * rho_a + Vdef_inc_od
                dP_od = _default_prob(VdefP_od, VrepP_od, rho_d)
                VP_od = _inclusive_two(VdefP_od, VrepP_od, rho_d, euler_gamma)

                # D) LEADER (O) repay value
                W_O_flat = np.empty(NB * NT_O)
                for jBOp in range(NB):
                    bO_prime = bOgrid[jBOp]
                    dPj = dP_cond_Orep[jBOp]

                    for it in range(NT_O):
                        # Part when P repays: expectation over bP'
                        EV_profile = 0.0
                        for jb in range(NB):
                            g_rep = TO_tau[it] + qO_both[jBOp, jb] * bO_prime - bO_now
                            vg = _v_pub(g_rep, omega_g, sigma_H)
                            cont = beta * EVO00[jBOp, jb]
                            EV_profile += p_bP_condrep[jBOp, jb] * (uO_tau[it] + vg + cont)

                        # Part when P defaults
                        g_def = TO_tau[it] + qO_onlyO[jBOp] * bO_prime - bO_now
                        vg_def = _v_pub(g_def, omega_g, sigma_H)
                        cont_def_O = beta * EVO01[jBOp, iBP0]
                        EV_defbranch = uO_tau[it] + vg_def + cont_def_O

                        W_O_flat[jBOp * NT_O + it] = (1.0 - dPj) * EV_profile + dPj * EV_defbranch

                Vrep_inc_O, probs_O = _logsumexp_1d(W_O_flat, rho_a)
                VrepO = euler_gamma * rho_a + Vrep_inc_O

                # marginal over bO'
                p_bO = np.zeros(NB)
                p_tauO = np.zeros(NT_O)
                for jBOp in range(NB):
                    for it in range(NT_O):
                        p_bO[jBOp] += probs_O[jBOp * NT_O + it]
                        p_tauO[it] += probs_O[jBOp * NT_O + it]
                EbO = 0.0
                for jb in range(NB):
                    EbO += p_bO[jb] * bOgrid[jb]
                EtO = 0.0
                for it in range(NT_O):
                    EtO += p_tauO[it] * tauO[it]

                # E) O default value
                cont_Odef = beta * (
                    (1.0 - dP_od) * _dot(p_bP_od, EVO10[iBO0, :]) +
                    dP_od * EVO11[iBO0, iBP0]
                )
                W_Odef = np.empty(NT_O)
                for it in range(NT_O):
                    vg = _v_pub(TO_d_tau[it], omega_g, sigma_H)
                    W_Odef[it] = uO_d_tau[it] + vg + cont_Odef
                Vdef_inc_O, p_tau_defO = _logsumexp_1d(W_Odef, rho_a)
                VdefO = euler_gamma * rho_a + Vdef_inc_O
                EtO_def = 0.0
                for it in range(NT_O):
                    EtO_def += p_tau_defO[it] * tauO[it]

                dO_here = _default_prob(VdefO, VrepO, rho_d)
                VO_here = _inclusive_two(VdefO, VrepO, rho_d, euler_gamma)

                # F) Aggregate P
                VP_if_Orep = _dot(p_bO, VP_cond_Orep)
                dP_if_Orep_here = _dot(p_bO, dP_cond_Orep)
                EbP_if_Orep_here = _dot(p_bO, EbP_condrep)
                EtP_if_Orep_here = _dot(p_bO, EtauP_condrep)

                VP_here = (1.0 - dO_here) * VP_if_Orep + dO_here * VP_od
                dP_here = (1.0 - dO_here) * dP_if_Orep_here + dO_here * dP_od

                # G) Lender consumption
                C_Orep = 0.0
                qO_pol_sum = 0.0
                qP_pol_sum = 0.0
                EbP_rep_sum = 0.0
                EtP_rep_sum = 0.0
                EtP_def_sum = 0.0

                for jBOp in range(NB):
                    pb = p_bO[jBOp]
                    if pb == 0.0:
                        continue
                    bO_prime = bOgrid[jBOp]
                    dPj = dP_cond_Orep[jBOp]

                    cost_both = 0.0
                    eq_qO = 0.0
                    eq_qP = 0.0
                    for jb in range(NB):
                        cost_both += p_bP_condrep[jBOp, jb] * (qO_both[jBOp, jb] * bO_prime + qP_both[jBOp, jb] * bPgrid[jb])
                        eq_qO += p_bP_condrep[jBOp, jb] * qO_both[jBOp, jb]
                        eq_qP += p_bP_condrep[jBOp, jb] * qP_both[jBOp, jb]

                    C_both = y_L + bO_now + bP_now - cost_both
                    C_onlyO = y_L + bO_now - qO_onlyO[jBOp] * bO_prime
                    C_Orep += pb * ((1.0 - dPj) * C_both + dPj * C_onlyO)

                    qO_pol_sum += pb * (1.0 - dPj) * eq_qO
                    qP_pol_sum += pb * (1.0 - dPj) * eq_qP

                    EbP_rep_sum += pb * EbP_condrep[jBOp]
                    EtP_rep_sum += pb * EtauP_condrep[jBOp]
                    EtP_def_sum += pb * EtauP_def_cond[jBOp]

                cost_onlyP = 0.0
                for jb in range(NB):
                    cost_onlyP += p_bP_od[jb] * qP_onlyP[jb] * bPgrid[jb]
                C_onlyP = y_L + bP_now - cost_onlyP
                C_Odef = (1.0 - dP_od) * C_onlyP + dP_od * y_L
                C_total = (1.0 - dO_here) * C_Orep + dO_here * C_Odef
                if C_total < 1e-12:
                    C_total = 1e-12
                mu_here = C_total ** (-sigma_L)

                # store
                VO00[iz2, iBO, iBP] = VO_here
                VP00[iz2, iBO, iBP] = VP_here
                dO00[iz2, iBO, iBP] = dO_here
                dP00[iz2, iBO, iBP] = dP_here
                mu00[iz2, iBO, iBP] = mu_here
                EbO_rep[iz2, iBO, iBP] = EbO
                EtauO_rep[iz2, iBO, iBP] = EtO
                EtauO_def[iz2, iBO, iBP] = EtO_def
                EbP_rep[iz2, iBO, iBP] = EbP_rep_sum
                EtauP_rep[iz2, iBO, iBP] = EtP_rep_sum
                EtauP_def[iz2, iBO, iBP] = EtP_def_sum
                dP_if_Orep_out[iz2, iBO, iBP] = dP_if_Orep_here
                EbP_if_Orep_out[iz2, iBO, iBP] = EbP_if_Orep_here
                EtauP_if_Orep_out[iz2, iBO, iBP] = EtP_if_Orep_here
                dP_if_Odef_out[iz2, iBO, iBP] = dP_od
                EbP_if_Odef_out[iz2, iBO, iBP] = EbP_od
                EtauP_if_Odef_out[iz2, iBO, iBP] = EtauP_od
                qO_pol_out[iz2, iBO, iBP] = qO_pol_sum
                qP_pol_out[iz2, iBO, iBP] = qP_pol_sum

    return (VO00, VP00, dO00, dP00, mu00,
            EbO_rep, EtauO_rep, EtauO_def,
            EbP_rep, EtauP_rep, EtauP_def,
            dP_if_Orep_out, EbP_if_Orep_out, EtauP_if_Orep_out,
            dP_if_Odef_out, EbP_if_Odef_out, EtauP_if_Odef_out,
            qO_pol_out, qP_pol_out)


@njit
def _dot(a, b):
    s = 0.0
    for i in range(a.size):
        s += a[i] * b[i]
    return s


# ============================================================
# 7. Regime (0,1): O has access, P excluded -- numba JIT
# ============================================================

@njit
def _solve_regime_01_core(
    NZ2, NB, NT_O, NT_P,
    bOgrid, tauO, tauP,
    iBO0, iBP0,
    uO_all, TO_all, uO_def_all, TO_def_all,
    uP_def_all, TP_def_all,
    NO00, NO01,
    EVO00, EVO01, EVO10, EVO11,
    EVP00, EVP01, EVP10, EVP11,
    sigma_H, omega_g, beta, sigma_L, y_L,
    rho_a, rho_d, euler_gamma, lam_reentry,
    newton_maxit, newton_tol
):
    VO01 = np.zeros((NZ2, NB, NB))
    VP01 = np.zeros((NZ2, NB, NB))
    dO01 = np.zeros((NZ2, NB, NB))
    dP01 = np.ones((NZ2, NB, NB))
    mu01 = np.zeros((NZ2, NB, NB))
    EbO_rep = np.zeros((NZ2, NB, NB))
    EtauO_rep = np.zeros((NZ2, NB, NB))
    EtauO_def = np.zeros((NZ2, NB, NB))
    EtauP_aut = np.zeros((NZ2, NB, NB))

    for iz2 in range(NZ2):
        uO_tau = uO_all[iz2, :]
        TO_tau = TO_all[iz2, :]
        uO_d_tau = uO_def_all[iz2, :]
        TO_d_tau = TO_def_all[iz2, :]
        uP_d_tau = uP_def_all[iz2, :]
        TP_d_tau = TP_def_all[iz2, :]

        for iBO in range(NB):
            bO_now = bOgrid[iBO]
            for iBP in range(NB):
                # Price schedule: mixture over next mP'
                NO_mix = np.empty(NB)
                for i in range(NB):
                    NO_mix[i] = lam_reentry * NO00[iz2, i, iBP0] + (1.0 - lam_reentry) * NO01[iz2, i, iBP0]
                A = y_L + bO_now
                K = np.empty(NB)
                for i in range(NB):
                    K[i] = NO_mix[i] * bOgrid[i]
                c = _solve_c_newton_1d(A, K, sigma_L, newton_maxit, newton_tol)
                qO = np.empty(NB)
                for i in range(NB):
                    qO[i] = NO_mix[i] * (c[i] ** sigma_L)

                # O repay value
                cont_rep = np.empty(NB)
                for i in range(NB):
                    cont_rep[i] = beta * (lam_reentry * EVO00[iz2, i, iBP0] + (1.0 - lam_reentry) * EVO01[iz2, i, iBP0])

                W_flat = np.empty(NB * NT_O)
                for jBOp in range(NB):
                    for it in range(NT_O):
                        g = TO_tau[it] + qO[jBOp] * bOgrid[jBOp] - bO_now
                        vg = _v_pub(g, omega_g, sigma_H)
                        W_flat[jBOp * NT_O + it] = uO_tau[it] + vg + cont_rep[jBOp]

                Vrep_inc, pO = _logsumexp_1d(W_flat, rho_a)
                VrepO = euler_gamma * rho_a + Vrep_inc

                p_bO = np.zeros(NB)
                p_tauO = np.zeros(NT_O)
                for jBOp in range(NB):
                    for it in range(NT_O):
                        idx = jBOp * NT_O + it
                        p_bO[jBOp] += pO[idx]
                        p_tauO[it] += pO[idx]
                EbO = _dot(p_bO, bOgrid)
                EtO = _dot(p_tauO, tauO)

                # O default value
                cont_def = beta * (lam_reentry * EVO10[iz2, iBO0, iBP0] + (1.0 - lam_reentry) * EVO11[iz2, iBO0, iBP0])
                W_def = np.empty(NT_O)
                for it in range(NT_O):
                    vg = _v_pub(TO_d_tau[it], omega_g, sigma_H)
                    W_def[it] = uO_d_tau[it] + vg + cont_def
                Vdef_inc, p_tau_def = _logsumexp_1d(W_def, rho_a)
                VdefO = euler_gamma * rho_a + Vdef_inc
                EtO_def = _dot(p_tau_def, tauO)

                dO_here = _default_prob(VdefO, VrepO, rho_d)
                VO_here = _inclusive_two(VdefO, VrepO, rho_d, euler_gamma)

                # P excluded value
                iBO_star = 0
                min_diff = abs(bOgrid[0] - EbO)
                for i in range(1, NB):
                    d = abs(bOgrid[i] - EbO)
                    if d < min_diff:
                        min_diff = d
                        iBO_star = i

                cont_P_re = (1.0 - dO_here) * EVP00[iz2, iBO_star, iBP0] + dO_here * EVP10[iz2, iBO0, iBP0]
                cont_P_st = (1.0 - dO_here) * EVP01[iz2, iBO_star, iBP0] + dO_here * EVP11[iz2, iBO0, iBP0]
                contP = beta * (lam_reentry * cont_P_re + (1.0 - lam_reentry) * cont_P_st)

                W_tauP = np.empty(NT_P)
                for it in range(NT_P):
                    vg = _v_pub(TP_d_tau[it], omega_g, sigma_H)
                    W_tauP[it] = uP_d_tau[it] + vg + contP
                VP_inc, p_tauP = _logsumexp_1d(W_tauP, rho_a)
                VP_here = euler_gamma * rho_a + VP_inc
                EtP = _dot(p_tauP, tauP)

                # Lender mu
                cost = 0.0
                for i in range(NB):
                    cost += p_bO[i] * qO[i] * bOgrid[i]
                C_rep = y_L + bO_now - cost
                C_def = y_L
                C = (1.0 - dO_here) * C_rep + dO_here * C_def
                if C < 1e-12:
                    C = 1e-12
                mu_here = C ** (-sigma_L)

                VO01[iz2, iBO, iBP] = VO_here
                VP01[iz2, iBO, iBP] = VP_here
                dO01[iz2, iBO, iBP] = dO_here
                mu01[iz2, iBO, iBP] = mu_here
                EbO_rep[iz2, iBO, iBP] = EbO
                EtauO_rep[iz2, iBO, iBP] = EtO
                EtauO_def[iz2, iBO, iBP] = EtO_def
                EtauP_aut[iz2, iBO, iBP] = EtP

    return (VO01, VP01, dO01, dP01, mu01,
            EbO_rep, EtauO_rep, EtauO_def, EtauP_aut)


# ============================================================
# 8. Regime (1,0): O excluded, P has access -- numba JIT
# ============================================================

@njit
def _solve_regime_10_core(
    NZ2, NB, NT_O, NT_P,
    bPgrid, tauO, tauP,
    iBO0, iBP0,
    uP_all, TP_all, uP_def_all, TP_def_all,
    uO_def_all, TO_def_all,
    NP00, NP10,
    EVO00, EVO01, EVO10, EVO11,
    EVP00, EVP01, EVP10, EVP11,
    sigma_H, omega_g, beta, sigma_L, y_L,
    rho_a, rho_d, euler_gamma, lam_reentry,
    newton_maxit, newton_tol
):
    VO10 = np.zeros((NZ2, NB, NB))
    VP10 = np.zeros((NZ2, NB, NB))
    dO10 = np.ones((NZ2, NB, NB))
    dP10 = np.zeros((NZ2, NB, NB))
    mu10 = np.zeros((NZ2, NB, NB))
    EbP_rep = np.zeros((NZ2, NB, NB))
    EtauP_rep = np.zeros((NZ2, NB, NB))
    EtauP_def = np.zeros((NZ2, NB, NB))
    EtauO_aut = np.zeros((NZ2, NB, NB))

    for iz2 in range(NZ2):
        uP_tau = uP_all[iz2, :]
        TP_tau = TP_all[iz2, :]
        uP_d_tau = uP_def_all[iz2, :]
        TP_d_tau = TP_def_all[iz2, :]
        uO_d_tau = uO_def_all[iz2, :]
        TO_d_tau = TO_def_all[iz2, :]

        for iBO in range(NB):
            for iBP in range(NB):
                bP_now = bPgrid[iBP]

                # P price schedule
                NP_mix = np.empty(NB)
                for i in range(NB):
                    NP_mix[i] = lam_reentry * NP00[iz2, iBO0, i] + (1.0 - lam_reentry) * NP10[iz2, iBO0, i]
                A = y_L + bP_now
                K = np.empty(NB)
                for i in range(NB):
                    K[i] = NP_mix[i] * bPgrid[i]
                c = _solve_c_newton_1d(A, K, sigma_L, newton_maxit, newton_tol)
                qP = np.empty(NB)
                for i in range(NB):
                    qP[i] = NP_mix[i] * (c[i] ** sigma_L)

                # P repay value
                cont_rep = np.empty(NB)
                for i in range(NB):
                    cont_rep[i] = beta * (lam_reentry * EVP00[iz2, iBO0, i] + (1.0 - lam_reentry) * EVP10[iz2, iBO0, i])

                W_flat = np.empty(NT_P * NB)
                for it in range(NT_P):
                    for jb in range(NB):
                        g = TP_tau[it] + qP[jb] * bPgrid[jb] - bP_now
                        vg = _v_pub(g, omega_g, sigma_H)
                        W_flat[it * NB + jb] = uP_tau[it] + vg + cont_rep[jb]
                Vrep_inc, probs = _logsumexp_1d(W_flat, rho_a)
                VrepP = euler_gamma * rho_a + Vrep_inc

                p_bP = np.zeros(NB)
                p_tauP = np.zeros(NT_P)
                for it in range(NT_P):
                    for jb in range(NB):
                        idx = it * NB + jb
                        p_bP[jb] += probs[idx]
                        p_tauP[it] += probs[idx]
                EbP = _dot(p_bP, bPgrid)
                EtP = _dot(p_tauP, tauP)

                # P default value
                cont_def = beta * (lam_reentry * EVP01[iz2, iBO0, iBP0] + (1.0 - lam_reentry) * EVP11[iz2, iBO0, iBP0])
                W_def = np.empty(NT_P)
                for it in range(NT_P):
                    vg = _v_pub(TP_d_tau[it], omega_g, sigma_H)
                    W_def[it] = uP_d_tau[it] + vg + cont_def
                Vdef_inc, p_tau_def = _logsumexp_1d(W_def, rho_a)
                VdefP = euler_gamma * rho_a + Vdef_inc
                EtP_def = _dot(p_tau_def, tauP)

                dP_here = _default_prob(VdefP, VrepP, rho_d)
                VP_here = _inclusive_two(VdefP, VrepP, rho_d, euler_gamma)

                # O excluded value
                iBP_star = 0
                min_diff = abs(bPgrid[0] - EbP)
                for i in range(1, NB):
                    d = abs(bPgrid[i] - EbP)
                    if d < min_diff:
                        min_diff = d
                        iBP_star = i

                cont_O_re = (1.0 - dP_here) * EVO00[iz2, iBO0, iBP_star] + dP_here * EVO01[iz2, iBO0, iBP0]
                cont_O_st = (1.0 - dP_here) * EVO10[iz2, iBO0, iBP_star] + dP_here * EVO11[iz2, iBO0, iBP0]
                contO = beta * (lam_reentry * cont_O_re + (1.0 - lam_reentry) * cont_O_st)

                W_tauO = np.empty(NT_O)
                for it in range(NT_O):
                    vg = _v_pub(TO_d_tau[it], omega_g, sigma_H)
                    W_tauO[it] = uO_d_tau[it] + vg + contO
                VO_inc, p_tauO = _logsumexp_1d(W_tauO, rho_a)
                VO_here = euler_gamma * rho_a + VO_inc
                EtO = _dot(p_tauO, tauO)

                # Lender mu
                cost = 0.0
                for i in range(NB):
                    cost += p_bP[i] * qP[i] * bPgrid[i]
                C_rep = y_L + bP_now - cost
                C = (1.0 - dP_here) * C_rep + dP_here * y_L
                if C < 1e-12:
                    C = 1e-12
                mu_here = C ** (-sigma_L)

                VP10[iz2, iBO, iBP] = VP_here
                VO10[iz2, iBO, iBP] = VO_here
                dP10[iz2, iBO, iBP] = dP_here
                mu10[iz2, iBO, iBP] = mu_here
                EbP_rep[iz2, iBO, iBP] = EbP
                EtauP_rep[iz2, iBO, iBP] = EtP
                EtauP_def[iz2, iBO, iBP] = EtP_def
                EtauO_aut[iz2, iBO, iBP] = EtO

    return (VO10, VP10, dO10, dP10, mu10,
            EbP_rep, EtauP_rep, EtauP_def, EtauO_aut)


# ============================================================
# 9. Regime (1,1): both excluded -- numba JIT
# ============================================================

@njit
def _solve_regime_11_core(
    NZ2, NB, NT_O, NT_P,
    tauO, tauP, iBO0, iBP0,
    uO_def_all, TO_def_all,
    uP_def_all, TP_def_all,
    EVO00, EVO01, EVO10, EVO11,
    EVP00, EVP01, EVP10, EVP11,
    sigma_H, omega_g, beta, y_L, sigma_L,
    rho_a, euler_gamma, lam_reentry
):
    VO11 = np.zeros((NZ2, NB, NB))
    VP11 = np.zeros((NZ2, NB, NB))
    dO11 = np.ones((NZ2, NB, NB))
    dP11 = np.ones((NZ2, NB, NB))
    mu11 = np.full((NZ2, NB, NB), y_L ** (-sigma_L))
    EtauO_aut = np.zeros((NZ2, NB, NB))
    EtauP_aut = np.zeros((NZ2, NB, NB))

    lam = lam_reentry
    for iz2 in range(NZ2):
        uO_d = uO_def_all[iz2, :]
        TO_d = TO_def_all[iz2, :]
        uP_d = uP_def_all[iz2, :]
        TP_d = TP_def_all[iz2, :]

        contO = beta * (
            lam * lam * EVO00[iz2, iBO0, iBP0] +
            lam * (1.0 - lam) * EVO01[iz2, iBO0, iBP0] +
            (1.0 - lam) * lam * EVO10[iz2, iBO0, iBP0] +
            (1.0 - lam) ** 2 * EVO11[iz2, iBO0, iBP0]
        )
        contP = beta * (
            lam * lam * EVP00[iz2, iBO0, iBP0] +
            lam * (1.0 - lam) * EVP01[iz2, iBO0, iBP0] +
            (1.0 - lam) * lam * EVP10[iz2, iBO0, iBP0] +
            (1.0 - lam) ** 2 * EVP11[iz2, iBO0, iBP0]
        )

        W_O = np.empty(NT_O)
        for it in range(NT_O):
            vg = _v_pub(TO_d[it], omega_g, sigma_H)
            W_O[it] = uO_d[it] + vg + contO
        incO, pO = _logsumexp_1d(W_O, rho_a)
        VO_here = euler_gamma * rho_a + incO
        EtO = _dot(pO, tauO)

        W_P = np.empty(NT_P)
        for it in range(NT_P):
            vg = _v_pub(TP_d[it], omega_g, sigma_H)
            W_P[it] = uP_d[it] + vg + contP
        incP, pP = _logsumexp_1d(W_P, rho_a)
        VP_here = euler_gamma * rho_a + incP
        EtP = _dot(pP, tauP)

        for iBO in range(NB):
            for iBP in range(NB):
                VO11[iz2, iBO, iBP] = VO_here
                VP11[iz2, iBO, iBP] = VP_here
                EtauO_aut[iz2, iBO, iBP] = EtO
                EtauP_aut[iz2, iBO, iBP] = EtP

    return (VO11, VP11, dO11, dP11, mu11, EtauO_aut, EtauP_aut)


# ============================================================
# 10. Wrapper functions calling numba cores
# ============================================================

def solve_regime_00(params, grids, uO, TO, uO_def, TO_def, uP, TP, uP_def, TP_def,
                    EV_VO, EV_VP, N_O, N_P):
    NZ2 = params.NZ * params.NZ
    NB = grids.bO.size
    NT_O = grids.tauO.size
    NT_P = grids.tauP.size
    result = _solve_regime_00_core(
        NZ2, NB, NT_O, NT_P,
        grids.bO, grids.bP, grids.tauO, grids.tauP,
        grids.iBO0, grids.iBP0,
        uO, TO, uO_def, TO_def,
        uP, TP, uP_def, TP_def,
        N_O[0, 0], N_P[0, 0], N_O[0, 1], N_P[1, 0],
        EV_VO[0, 0], EV_VO[0, 1], EV_VO[1, 0], EV_VO[1, 1],
        EV_VP[0, 0], EV_VP[0, 1], EV_VP[1, 0], EV_VP[1, 1],
        params.sigma_H, params.omega_g, params.beta, params.sigma_L, params.y_L,
        params.rho_a, params.rho_d, params.euler_gamma,
        params.newton_maxit, params.newton_tol
    )
    keys = ["VO", "VP", "dO", "dP", "mu",
            "EbO_rep", "EtauO_rep", "EtauO_def",
            "EbP_rep", "EtauP_rep", "EtauP_def",
            "dP_if_Orep", "EbP_if_Orep", "EtauP_if_Orep",
            "dP_if_Odef", "EbP_if_Odef", "EtauP_if_Odef",
            "qO_pol", "qP_pol"]
    return dict(zip(keys, result))


def solve_regime_01(params, grids, uO, TO, uO_def, TO_def, uP_def, TP_def,
                    EV_VO, EV_VP, N_O):
    NZ2 = params.NZ * params.NZ
    NB = grids.bO.size
    NT_O = grids.tauO.size
    NT_P = grids.tauP.size
    result = _solve_regime_01_core(
        NZ2, NB, NT_O, NT_P,
        grids.bO, grids.tauO, grids.tauP,
        grids.iBO0, grids.iBP0,
        uO, TO, uO_def, TO_def,
        uP_def, TP_def,
        N_O[0, 0], N_O[0, 1],
        EV_VO[0, 0], EV_VO[0, 1], EV_VO[1, 0], EV_VO[1, 1],
        EV_VP[0, 0], EV_VP[0, 1], EV_VP[1, 0], EV_VP[1, 1],
        params.sigma_H, params.omega_g, params.beta, params.sigma_L, params.y_L,
        params.rho_a, params.rho_d, params.euler_gamma, params.lam_reentry,
        params.newton_maxit, params.newton_tol
    )
    keys = ["VO", "VP", "dO", "dP", "mu",
            "EbO_rep", "EtauO_rep", "EtauO_def", "EtauP_aut"]
    return dict(zip(keys, result))


def solve_regime_10(params, grids, uP, TP, uP_def, TP_def, uO_def, TO_def,
                    EV_VO, EV_VP, N_P):
    NZ2 = params.NZ * params.NZ
    NB = grids.bO.size
    NT_O = grids.tauO.size
    NT_P = grids.tauP.size
    result = _solve_regime_10_core(
        NZ2, NB, NT_O, NT_P,
        grids.bP, grids.tauO, grids.tauP,
        grids.iBO0, grids.iBP0,
        uP, TP, uP_def, TP_def,
        uO_def, TO_def,
        N_P[0, 0], N_P[1, 0],
        EV_VO[0, 0], EV_VO[0, 1], EV_VO[1, 0], EV_VO[1, 1],
        EV_VP[0, 0], EV_VP[0, 1], EV_VP[1, 0], EV_VP[1, 1],
        params.sigma_H, params.omega_g, params.beta, params.sigma_L, params.y_L,
        params.rho_a, params.rho_d, params.euler_gamma, params.lam_reentry,
        params.newton_maxit, params.newton_tol
    )
    keys = ["VO", "VP", "dO", "dP", "mu",
            "EbP_rep", "EtauP_rep", "EtauP_def", "EtauO_aut"]
    return dict(zip(keys, result))


def solve_regime_11(params, grids, uO_def, TO_def, uP_def, TP_def,
                    EV_VO, EV_VP):
    NZ2 = params.NZ * params.NZ
    NB = grids.bO.size
    NT_O = grids.tauO.size
    NT_P = grids.tauP.size
    result = _solve_regime_11_core(
        NZ2, NB, NT_O, NT_P,
        grids.tauO, grids.tauP, grids.iBO0, grids.iBP0,
        uO_def, TO_def, uP_def, TP_def,
        EV_VO[0, 0], EV_VO[0, 1], EV_VO[1, 0], EV_VO[1, 1],
        EV_VP[0, 0], EV_VP[0, 1], EV_VP[1, 0], EV_VP[1, 1],
        params.sigma_H, params.omega_g, params.beta, params.y_L, params.sigma_L,
        params.rho_a, params.euler_gamma, params.lam_reentry
    )
    keys = ["VO", "VP", "dO", "dP", "mu", "EtauO_aut", "EtauP_aut"]
    return dict(zip(keys, result))


# ============================================================
# 11. Main stationary solver loop
# ============================================================

def solve_stationary_appendixC(params: Params, grids: Grids, Pi2,
                                uO, TO, uO_def, TO_def,
                                uP, TP, uP_def, TP_def):
    eq = init_eq(params, grids)
    NZ2 = params.NZ * params.NZ
    NB = grids.bO.size
    shape = (NZ2, NB, NB, 2, 2)

    # JIT warmup: run one iteration with small data to trigger compilation
    print("JIT compiling numba kernels (first call)...")
    t0 = time.time()

    EV_VO, EV_VP, N_O, N_P = build_expectations(params, grids, Pi2, eq)
    _ = solve_regime_00(params, grids, uO, TO, uO_def, TO_def,
                        uP, TP, uP_def, TP_def, EV_VO, EV_VP, N_O, N_P)
    _ = solve_regime_01(params, grids, uO, TO, uO_def, TO_def,
                        uP_def, TP_def, EV_VO, EV_VP, N_O)
    _ = solve_regime_10(params, grids, uP, TP, uP_def, TP_def,
                        uO_def, TO_def, EV_VO, EV_VP, N_P)
    _ = solve_regime_11(params, grids, uO_def, TO_def, uP_def, TP_def,
                        EV_VO, EV_VP)
    print(f"JIT compilation done in {time.time()-t0:.1f}s")

    for it in range(params.max_iter):
        t_iter = time.time()
        EV_VO, EV_VP, N_O, N_P = build_expectations(params, grids, Pi2, eq)

        out00 = solve_regime_00(params, grids, uO, TO, uO_def, TO_def,
                                uP, TP, uP_def, TP_def, EV_VO, EV_VP, N_O, N_P)
        out01 = solve_regime_01(params, grids, uO, TO, uO_def, TO_def,
                                uP_def, TP_def, EV_VO, EV_VP, N_O)
        out10 = solve_regime_10(params, grids, uP, TP, uP_def, TP_def,
                                uO_def, TO_def, EV_VO, EV_VP, N_P)
        out11 = solve_regime_11(params, grids, uO_def, TO_def, uP_def, TP_def,
                                EV_VO, EV_VP)

        VO_new = np.zeros(shape)
        VP_new = np.zeros(shape)
        dO_new = np.zeros(shape)
        dP_new = np.zeros(shape)
        mu_new = np.zeros(shape)

        for (mO, mP, out) in [(0, 0, out00), (0, 1, out01), (1, 0, out10), (1, 1, out11)]:
            VO_new[:, :, :, mO, mP] = out["VO"]
            VP_new[:, :, :, mO, mP] = out["VP"]
            dO_new[:, :, :, mO, mP] = out["dO"]
            dP_new[:, :, :, mO, mP] = out["dP"]
            mu_new[:, :, :, mO, mP] = out["mu"]

        diffV = max(np.max(np.abs(VO_new - eq.VO)), np.max(np.abs(VP_new - eq.VP)))
        diffD = max(np.max(np.abs(dO_new - eq.dO)), np.max(np.abs(dP_new - eq.dP)))
        diffM = np.max(np.abs(mu_new - eq.muL))
        diff = max(diffV, diffD, diffM)

        dt = time.time() - t_iter
        print(f"iter {it:3d}  diff={diff:.3e}  (V={diffV:.3e}, d={diffD:.3e}, mu={diffM:.3e})  [{dt:.2f}s]")

        eq.VO = (1.0 - params.damp) * eq.VO + params.damp * VO_new
        eq.VP = (1.0 - params.damp) * eq.VP + params.damp * VP_new
        eq.dO = (1.0 - params.damp) * eq.dO + params.damp * dO_new
        eq.dP = (1.0 - params.damp) * eq.dP + params.damp * dP_new
        eq.muL = (1.0 - params.damp) * eq.muL + params.damp * mu_new

        # Store policies for regime (0,0)
        eq.EbO_rep[:, :, :, 0, 0] = out00["EbO_rep"]
        eq.EtauO_rep[:, :, :, 0, 0] = out00["EtauO_rep"]
        eq.EtauO_def[:, :, :, 0, 0] = out00["EtauO_def"]
        eq.EbP_rep[:, :, :, 0, 0] = out00["EbP_rep"]
        eq.EtauP_rep[:, :, :, 0, 0] = out00["EtauP_rep"]
        eq.EtauP_def[:, :, :, 0, 0] = out00["EtauP_def"]

        eq.dP_if_Orep[:, :, :, 0, 0] = out00["dP_if_Orep"]
        eq.EbP_if_Orep[:, :, :, 0, 0] = out00["EbP_if_Orep"]
        eq.EtauP_if_Orep[:, :, :, 0, 0] = out00["EtauP_if_Orep"]
        eq.dP_if_Odef[:, :, :, 0, 0] = out00["dP_if_Odef"]
        eq.EbP_if_Odef[:, :, :, 0, 0] = out00["EbP_if_Odef"]
        eq.EtauP_if_Odef[:, :, :, 0, 0] = out00["EtauP_if_Odef"]

        eq.qO_pol[:, :, :, 0, 0] = out00["qO_pol"]
        eq.qP_pol[:, :, :, 0, 0] = out00["qP_pol"]

        # Store policies for other regimes
        eq.EbO_rep[:, :, :, 0, 1] = out01["EbO_rep"]
        eq.EtauO_rep[:, :, :, 0, 1] = out01["EtauO_rep"]
        eq.EtauO_def[:, :, :, 0, 1] = out01["EtauO_def"]

        eq.EbP_rep[:, :, :, 1, 0] = out10["EbP_rep"]
        eq.EtauP_rep[:, :, :, 1, 0] = out10["EtauP_rep"]
        eq.EtauP_def[:, :, :, 1, 0] = out10["EtauP_def"]

        if diff < params.tol:
            print("Converged.")
            break

    return eq


# ============================================================
# 12. Simulation with discrete default draws, expected repay policies
# ============================================================

def draw_markov(P, s0, T, rng):
    s = np.empty(T + 1, dtype=int)
    s[0] = s0
    for t in range(T):
        s[t + 1] = rng.choice(P.shape[0], p=P[s[t], :])
    return s


def simulate(params: Params, grids: Grids, Pi2, eq: Eq,
             zO, zP, zO_def, zP_def,
             T=10000, burn=2000, seed=0):
    rng = np.random.default_rng(seed)
    NZ2 = params.NZ * params.NZ
    NB = grids.bO.size
    iBO0, iBP0 = grids.iBO0, grids.iBP0

    iz0 = NZ2 // 2
    iz_path = draw_markov(Pi2, iz0, T, rng)

    iBO = iBO0
    iBP = iBP0
    mO = 0
    mP = 0

    DO = np.zeros(T, dtype=int)
    DP = np.zeros(T, dtype=int)
    bO = np.zeros(T); bP = np.zeros(T)
    bO_p = np.zeros(T); bP_p = np.zeros(T)
    tauO = np.zeros(T); tauP = np.zeros(T)
    zO_used = np.zeros(T); zP_used = np.zeros(T)
    lO = np.zeros(T); lP = np.zeros(T)
    yO = np.zeros(T); yP = np.zeros(T)
    cO = np.zeros(T); cP = np.zeros(T)
    TO_tax = np.zeros(T); TP_tax = np.zeros(T)
    gO = np.zeros(T); gP = np.zeros(T)
    qO = np.zeros(T); qP = np.zeros(T)
    CL = np.zeros(T)

    for t in range(T):
        iz2 = int(iz_path[t])
        bO[t] = grids.bO[iBO]
        bP[t] = grids.bP[iBP]

        # O default draw
        if mO == 1:
            DO[t] = 1
        else:
            pO_val = float(eq.dO[iz2, iBO, iBP, mO, mP])
            DO[t] = 1 if rng.random() < pO_val else 0

        if DO[t] == 1:
            bO_p[t] = 0.0
            tauO[t] = float(eq.EtauO_def[iz2, iBO, iBP, mO, mP])
        else:
            bO_p[t] = float(eq.EbO_rep[iz2, iBO, iBP, mO, mP])
            tauO[t] = float(eq.EtauO_rep[iz2, iBO, iBP, mO, mP])

        # P default draw
        if mP == 1:
            DP[t] = 1
        else:
            if (mO, mP) == (0, 0):
                if DO[t] == 0:
                    pP_val = float(eq.dP_if_Orep[iz2, iBO, iBP, 0, 0])
                else:
                    pP_val = float(eq.dP_if_Odef[iz2, iBO, iBP, 0, 0])
            else:
                pP_val = float(eq.dP[iz2, iBO, iBP, mO, mP])
            DP[t] = 1 if rng.random() < pP_val else 0

        if DP[t] == 1:
            bP_p[t] = 0.0
            tauP[t] = float(eq.EtauP_def[iz2, iBO, iBP, mO, mP])
        else:
            if (mO, mP) == (0, 0):
                if DO[t] == 0:
                    bP_p[t] = float(eq.EbP_if_Orep[iz2, iBO, iBP, 0, 0])
                    tauP[t] = float(eq.EtauP_if_Orep[iz2, iBO, iBP, 0, 0])
                else:
                    bP_p[t] = float(eq.EbP_if_Odef[iz2, iBO, iBP, 0, 0])
                    tauP[t] = float(eq.EtauP_if_Odef[iz2, iBO, iBP, 0, 0])
            else:
                bP_p[t] = float(eq.EbP_rep[iz2, iBO, iBP, mO, mP])
                tauP[t] = float(eq.EtauP_rep[iz2, iBO, iBP, mO, mP])

        qO[t] = float(eq.qO_pol[iz2, iBO, iBP, 0, 0])
        qP[t] = float(eq.qP_pol[iz2, iBO, iBP, 0, 0])

        # Allocations
        zO_used[t] = zO_def[iz2] if DO[t] == 1 else zO[iz2]
        zP_used[t] = zP_def[iz2] if DP[t] == 1 else zP[iz2]

        lO[t] = (zO_used[t] / (params.theta * (1.0 + tauO[t]))) ** (1.0 / params.nu)
        lP[t] = (zP_used[t] / (params.theta * (1.0 + tauP[t]))) ** (1.0 / params.nu)

        yO[t] = zO_used[t] * lO[t]
        yP[t] = zP_used[t] * lP[t]

        cO[t] = yO[t] / (1.0 + tauO[t])
        cP[t] = yP[t] / (1.0 + tauP[t])

        TO_tax[t] = tauO[t] * cO[t]
        TP_tax[t] = tauP[t] * cP[t]

        if DO[t] == 0:
            gO[t] = TO_tax[t] + qO[t] * bO_p[t] - bO[t]
        else:
            gO[t] = TO_tax[t]

        if DP[t] == 0:
            gP[t] = TP_tax[t] + qP[t] * bP_p[t] - bP[t]
        else:
            gP[t] = TP_tax[t]

        CL[t] = params.y_L + (1 - DO[t]) * bO[t] + (1 - DP[t]) * bP[t] - qO[t] * bO_p[t] - qP[t] * bP_p[t]

        # Market access transition
        if mO == 0 and DO[t] == 1:
            mO_next = 1
        elif mO == 1:
            mO_next = 0 if rng.random() < params.lam_reentry else 1
        else:
            mO_next = 0

        if mP == 0 and DP[t] == 1:
            mP_next = 1
        elif mP == 1:
            mP_next = 0 if rng.random() < params.lam_reentry else 1
        else:
            mP_next = 0

        iBO = int(np.argmin(np.abs(grids.bO - bO_p[t])))
        iBP = int(np.argmin(np.abs(grids.bP - bP_p[t])))

        mO, mP = mO_next, mP_next

    sl = slice(burn, T)
    return {
        "DO": DO[sl], "DP": DP[sl],
        "bO": bO[sl], "bP": bP[sl],
        "bO_p": bO_p[sl], "bP_p": bP_p[sl],
        "tauO": tauO[sl], "tauP": tauP[sl],
        "zO": zO_used[sl], "zP": zP_used[sl],
        "lO": lO[sl], "lP": lP[sl],
        "yO": yO[sl], "yP": yP[sl],
        "cO": cO[sl], "cP": cP[sl],
        "TO_tax": TO_tax[sl], "TP_tax": TP_tax[sl],
        "gO": gO[sl], "gP": gP[sl],
        "qO": qO[sl], "qP": qP[sl],
        "CL": CL[sl],
    }


# ============================================================
# 13. Event study around O default
# ============================================================

def event_study_around_defaults(sim, window=10):
    DO = sim["DO"]
    T = DO.size
    events = np.where(DO == 1)[0]
    events = events[(events >= window) & (events < T - window)]
    if events.size == 0:
        return None

    def stack_series(x):
        X = np.stack([x[e - window:e + window + 1] for e in events], axis=0)
        return X.mean(axis=0)

    out = {"event_time": np.arange(-window, window + 1)}
    for k, v in sim.items():
        if v.ndim == 1 and v.size == T:
            out[k] = stack_series(v.astype(float))
    out["num_events"] = events.size
    return out


# ============================================================
# 14. Event study plotting
# ============================================================

def plot_event_study(ev, sim, savepath="event_study_O_default.png"):
    """
    Plot trajectories of all macro variables around O default events.
    Creates a large multi-panel figure with:
      - Row 1: Default indicators & productivity
      - Row 2: Output, consumption, labor
      - Row 3: Tax rate, tax revenue, public goods
      - Row 4: Debt (current & next), bond prices
      - Row 5: Lender consumption & credit spreads
    Each panel shows O (blue) and P (red) where applicable.
    """
    import matplotlib
    matplotlib.use("Agg")
    import matplotlib.pyplot as plt
    from matplotlib.ticker import MaxNLocator

    t = ev["event_time"]
    n_events = ev["num_events"]

    # Unconditional means for reference lines
    means = {k: v.mean() for k, v in sim.items() if hasattr(v, 'mean')}

    # Color scheme
    cO = "#1f77b4"   # blue for O
    cP = "#d62728"   # red for P
    cL = "#2ca02c"   # green for lender
    cG = "#7f7f7f"   # gray for reference

    fig, axes = plt.subplots(6, 3, figsize=(18, 28))
    fig.suptitle(
        f"Event Study: Trajectories around Country O Default\n"
        f"({n_events} events, window = [{t[0]}, {t[-1]}])",
        fontsize=16, fontweight="bold", y=0.995
    )

    def _plot_panel(ax, title, ylabel,
                    series_O=None, series_P=None, series_L=None,
                    label_O="Country O", label_P="Country P", label_L="Lender",
                    mean_O=None, mean_P=None, mean_L=None,
                    shade_default=True, percent=False):
        """Helper to plot one panel."""
        if series_O is not None:
            vals = series_O * 100 if percent else series_O
            ax.plot(t, vals, color=cO, linewidth=2, label=label_O, marker="o", markersize=3)
            if mean_O is not None:
                m = mean_O * 100 if percent else mean_O
                ax.axhline(m, color=cO, linestyle="--", alpha=0.35, linewidth=1)
        if series_P is not None:
            vals = series_P * 100 if percent else series_P
            ax.plot(t, vals, color=cP, linewidth=2, label=label_P, marker="s", markersize=3)
            if mean_P is not None:
                m = mean_P * 100 if percent else mean_P
                ax.axhline(m, color=cP, linestyle="--", alpha=0.35, linewidth=1)
        if series_L is not None:
            vals = series_L * 100 if percent else series_L
            ax.plot(t, vals, color=cL, linewidth=2, label=label_L, marker="^", markersize=3)
            if mean_L is not None:
                m = mean_L * 100 if percent else mean_L
                ax.axhline(m, color=cL, linestyle="--", alpha=0.35, linewidth=1)
        ax.axvline(0, color="black", linestyle="-", linewidth=1.5, alpha=0.7)
        if shade_default:
            ax.axvspan(-0.5, 0.5, color="orange", alpha=0.12)
        ax.set_title(title, fontsize=12, fontweight="bold")
        ax.set_ylabel(ylabel, fontsize=10)
        ax.set_xlabel("Event time (0 = O default)", fontsize=9)
        ax.legend(fontsize=9, loc="best")
        ax.grid(True, alpha=0.3)
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))

    # ================================================================
    # Row 0: Default probabilities & productivity
    # ================================================================
    _plot_panel(axes[0, 0], "Default Indicator (avg)", "Probability",
                series_O=ev["DO"], series_P=ev["DP"],
                mean_O=means.get("DO"), mean_P=means.get("DP"))

    _plot_panel(axes[0, 1], "Productivity z (effective)", "z",
                series_O=ev["zO"], series_P=ev["zP"],
                mean_O=means.get("zO"), mean_P=means.get("zP"))

    # Spread = 1/q - 1 (annualized for one-period bond)
    spread_O = 1.0 / np.maximum(ev["qO"], 1e-6) - 1.0
    spread_P = 1.0 / np.maximum(ev["qP"], 1e-6) - 1.0
    mean_spread_O = 1.0 / max(means.get("qO", 1.0), 1e-6) - 1.0
    mean_spread_P = 1.0 / max(means.get("qP", 1.0), 1e-6) - 1.0
    _plot_panel(axes[0, 2], "Credit Spread (1/q - 1)", "Spread",
                series_O=spread_O, series_P=spread_P,
                mean_O=mean_spread_O, mean_P=mean_spread_P,
                percent=True)
    axes[0, 2].set_ylabel("Spread (%)")

    # ================================================================
    # Row 1: Output, Consumption, Labor
    # ================================================================
    _plot_panel(axes[1, 0], "Output y = z * l", "y",
                series_O=ev["yO"], series_P=ev["yP"],
                mean_O=means.get("yO"), mean_P=means.get("yP"))

    _plot_panel(axes[1, 1], "Private Consumption c", "c",
                series_O=ev["cO"], series_P=ev["cP"],
                mean_O=means.get("cO"), mean_P=means.get("cP"))

    _plot_panel(axes[1, 2], "Labor l", "l",
                series_O=ev["lO"], series_P=ev["lP"],
                mean_O=means.get("lO"), mean_P=means.get("lP"))

    # ================================================================
    # Row 2: Tax rate, Tax revenue, Public goods
    # ================================================================
    _plot_panel(axes[2, 0], "Tax Rate tau", "tau",
                series_O=ev["tauO"], series_P=ev["tauP"],
                mean_O=means.get("tauO"), mean_P=means.get("tauP"))

    _plot_panel(axes[2, 1], "Tax Revenue T = tau * c", "T",
                series_O=ev["TO_tax"], series_P=ev["TP_tax"],
                mean_O=means.get("TO_tax"), mean_P=means.get("TP_tax"))

    _plot_panel(axes[2, 2], "Public Goods g", "g",
                series_O=ev["gO"], series_P=ev["gP"],
                mean_O=means.get("gO"), mean_P=means.get("gP"))

    # ================================================================
    # Row 3: Debt (current obligation), Next-period debt, Bond prices
    # ================================================================
    _plot_panel(axes[3, 0], "Current Debt b (due today)", "b",
                series_O=ev["bO"], series_P=ev["bP"],
                mean_O=means.get("bO"), mean_P=means.get("bP"))

    _plot_panel(axes[3, 1], "Next-Period Debt b'", "b'",
                series_O=ev["bO_p"], series_P=ev["bP_p"],
                mean_O=means.get("bO_p"), mean_P=means.get("bP_p"))

    _plot_panel(axes[3, 2], "Bond Price q", "q",
                series_O=ev["qO"], series_P=ev["qP"],
                mean_O=means.get("qO"), mean_P=means.get("qP"))

    # ================================================================
    # Row 4: Net resource transfer, Debt-to-output, Lender
    # ================================================================
    # Net transfer from lender: q*b' - (1-d)*b  (positive = borrowing)
    net_O = ev["qO"] * ev["bO_p"] - (1.0 - ev["DO"]) * ev["bO"]
    net_P = ev["qP"] * ev["bP_p"] - (1.0 - ev["DP"]) * ev["bP"]
    mn_O = means.get("qO", 0) * means.get("bO_p", 0) - (1.0 - means.get("DO", 0)) * means.get("bO", 0)
    mn_P = means.get("qP", 0) * means.get("bP_p", 0) - (1.0 - means.get("DP", 0)) * means.get("bP", 0)
    _plot_panel(axes[4, 0], "Net Borrowing (q*b' - (1-d)*b)", "Net flow",
                series_O=net_O, series_P=net_P,
                mean_O=mn_O, mean_P=mn_P)

    # Debt-to-output ratio
    dty_O = ev["bO"] / np.maximum(ev["yO"], 1e-6)
    dty_P = ev["bP"] / np.maximum(ev["yP"], 1e-6)
    mdty_O = means.get("bO", 0) / max(means.get("yO", 1), 1e-6)
    mdty_P = means.get("bP", 0) / max(means.get("yP", 1), 1e-6)
    _plot_panel(axes[4, 1], "Debt-to-Output Ratio b/y", "b/y",
                series_O=dty_O, series_P=dty_P,
                mean_O=mdty_O, mean_P=mdty_P,
                percent=True)
    axes[4, 1].set_ylabel("b/y (%)")

    _plot_panel(axes[4, 2], "Lender Consumption C_L", "C_L",
                series_L=ev["CL"], mean_L=means.get("CL"),
                label_L="Lender $C_L$")

    # ================================================================
    # Row 5: Combined view & summary table
    # ================================================================
    # Panel: O vs P output gap relative to unconditional mean
    yO_dev = (ev["yO"] / means.get("yO", 1) - 1.0) * 100
    yP_dev = (ev["yP"] / means.get("yP", 1) - 1.0) * 100
    _plot_panel(axes[5, 0], "Output Deviation from Mean (%)", "% deviation",
                series_O=yO_dev, series_P=yP_dev,
                label_O="O output", label_P="P output")
    axes[5, 0].axhline(0, color=cG, linestyle="-", linewidth=1, alpha=0.5)

    # Panel: consumption deviation
    cO_dev = (ev["cO"] / means.get("cO", 1) - 1.0) * 100
    cP_dev = (ev["cP"] / means.get("cP", 1) - 1.0) * 100
    _plot_panel(axes[5, 1], "Consumption Deviation from Mean (%)", "% deviation",
                series_O=cO_dev, series_P=cP_dev,
                label_O="O consumption", label_P="P consumption")
    axes[5, 1].axhline(0, color=cG, linestyle="-", linewidth=1, alpha=0.5)

    # Panel: CL deviation
    CL_dev = (ev["CL"] / means.get("CL", 1) - 1.0) * 100
    _plot_panel(axes[5, 2], "Lender Consumption Deviation (%)", "% deviation",
                series_L=CL_dev, label_L="$C_L$ deviation")
    axes[5, 2].axhline(0, color=cG, linestyle="-", linewidth=1, alpha=0.5)

    plt.tight_layout(rect=[0, 0, 1, 0.98])
    plt.savefig(savepath, dpi=150, bbox_inches="tight")
    plt.close(fig)
    print(f"Event study figure saved to: {savepath}")


def print_event_table(ev, sim):
    """Print a detailed table of event-time values at key dates."""
    t = ev["event_time"]
    idx_m5 = np.argmin(np.abs(t - (-5)))
    idx_m1 = np.argmin(np.abs(t - (-1)))
    idx_0  = np.argmin(np.abs(t - 0))
    idx_p1 = np.argmin(np.abs(t - 1))
    idx_p5 = np.argmin(np.abs(t - 5))
    cols = [idx_m5, idx_m1, idx_0, idx_p1, idx_p5]
    col_names = ["t=-5", "t=-1", "t=0", "t=+1", "t=+5"]

    means = {k: v.mean() for k, v in sim.items() if hasattr(v, 'mean')}

    rows = [
        ("DO  (O default)",   "DO",     "{:.4f}"),
        ("DP  (P default)",   "DP",     "{:.4f}"),
        ("zO  (O prod)",      "zO",     "{:.4f}"),
        ("zP  (P prod)",      "zP",     "{:.4f}"),
        ("yO  (O output)",    "yO",     "{:.4f}"),
        ("yP  (P output)",    "yP",     "{:.4f}"),
        ("cO  (O consump)",   "cO",     "{:.4f}"),
        ("cP  (P consump)",   "cP",     "{:.4f}"),
        ("lO  (O labor)",     "lO",     "{:.4f}"),
        ("lP  (P labor)",     "lP",     "{:.4f}"),
        ("tauO (O tax rate)", "tauO",   "{:.4f}"),
        ("tauP (P tax rate)", "tauP",   "{:.4f}"),
        ("TO  (O tax rev)",   "TO_tax", "{:.4f}"),
        ("TP  (P tax rev)",   "TP_tax", "{:.4f}"),
        ("gO  (O pub goods)", "gO",     "{:.4f}"),
        ("gP  (P pub goods)", "gP",     "{:.4f}"),
        ("bO  (O debt)",      "bO",     "{:.4f}"),
        ("bP  (P debt)",      "bP",     "{:.4f}"),
        ("bO' (O next debt)", "bO_p",   "{:.4f}"),
        ("bP' (P next debt)", "bP_p",   "{:.4f}"),
        ("qO  (O bond px)",   "qO",     "{:.6f}"),
        ("qP  (P bond px)",   "qP",     "{:.6f}"),
        ("CL  (lender C)",    "CL",     "{:.4f}"),
    ]

    header = f"{'Variable':<22}" + "".join(f"{c:>10}" for c in col_names) + f"{'Uncond':>10}"
    print("\n" + "=" * len(header))
    print(f"Event Study Table ({ev['num_events']} O-default events)")
    print("=" * len(header))
    print(header)
    print("-" * len(header))
    for label, key, fmt in rows:
        if key not in ev:
            continue
        vals = "".join(fmt.format(ev[key][c]).rjust(10) for c in cols)
        unc = fmt.format(means.get(key, 0.0)).rjust(10)
        print(f"{label:<22}{vals}{unc}")
    print("=" * len(header))


# ============================================================
# 15. Run
# ============================================================

if __name__ == "__main__":
    params = Params()
    grids = make_grids_10()

    print("Building joint productivity process...")
    zO, zP, zO_def, zP_def, Pi2 = build_joint_z(params)

    print("Precomputing static household block...")
    uO, TO, uO_def, TO_def, uP, TP, uP_def, TP_def = \
        _precompute_static_arrays(zO, zP, zO_def, zP_def,
                                   grids.tauO, grids.tauP,
                                   params.theta, params.nu, params.sigma_H, params.omega_g)

    print("Starting stationary solver...")
    t0 = time.time()
    eq = solve_stationary_appendixC(params, grids, Pi2,
                                     uO, TO, uO_def, TO_def,
                                     uP, TP, uP_def, TP_def)
    print(f"Solver completed in {time.time()-t0:.1f}s")

    print("\nRunning simulation...")
    sim = simulate(params, grids, Pi2, eq, zO, zP, zO_def, zP_def,
                   T=10000, burn=2000, seed=123)

    print("\n=== Simulation Summary ===")
    print(f"O default rate:  {sim['DO'].mean():.4f}")
    print(f"P default rate:  {sim['DP'].mean():.4f}")
    print(f"Mean bO:         {sim['bO'].mean():.4f}")
    print(f"Mean bP:         {sim['bP'].mean():.4f}")
    print(f"Mean tauO:       {sim['tauO'].mean():.4f}")
    print(f"Mean tauP:       {sim['tauP'].mean():.4f}")
    print(f"Mean yO:         {sim['yO'].mean():.4f}")
    print(f"Mean yP:         {sim['yP'].mean():.4f}")
    print(f"Mean cO:         {sim['cO'].mean():.4f}")
    print(f"Mean cP:         {sim['cP'].mean():.4f}")
    print(f"Mean gO:         {sim['gO'].mean():.4f}")
    print(f"Mean gP:         {sim['gP'].mean():.4f}")
    print(f"Mean qO:         {sim['qO'].mean():.6f}")
    print(f"Mean qP:         {sim['qP'].mean():.6f}")
    print(f"Mean CL:         {sim['CL'].mean():.4f}")

    ev = event_study_around_defaults(sim, window=10)
    if ev is not None:
        print(f"\n=== Event Study (O default, {ev['num_events']} events) ===")
        idx0 = 10
        print(f"Avg P default at t=0:  {ev['DP'][idx0]:.4f}")
        print(f"Avg qP at t=0:         {ev['qP'][idx0]:.6f}")
        print(f"Avg yP at t=0:         {ev['yP'][idx0]:.4f}")
        print(f"Avg qO at t=0:         {ev['qO'][idx0]:.6f}")
        print(f"Avg yO at t=0:         {ev['yO'][idx0]:.4f}")

        # Detailed table
        print_event_table(ev, sim)

        # Multi-panel figure
        plot_event_study(ev, sim, savepath="event_study_O_default.png")
    else:
        print("\nNo O default events found in simulation.")
